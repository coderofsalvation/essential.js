// Generated by CoffeeScript 1.9.2

/*
 * Essential.js 1.1.17
 * @author Cedric Ruiz
 * @license MIT
 */

(function() {
  var K, _, all, any, ap, apply, applyNew, binary, builtin, chain, compose, concat, countBy, curry, deepClone, deepExtend, deepPluck, deepWhere, drop, dups, each, eq, extend, filter, first, flatMap, flatten, flip, flip3, fmap, fold, fold1, foldr, foldr1, forOwn, format, gmatch, groupBy, id, inArray, indexOf, initial, intercalate, interleave, intersection, intersperse, isType, last, liftA, map, nary, ncurry, nflip, notEq, notF, over, pairs, partial, pcompose, permutations, pluck, powerset, range, remove, rest, seqM, sequence, shuffle, slice, sortBy, take, template, toArray, toObject, typeOf, unary, union, unique, uniqueBy, unzipObject, values, variadic, where, zip, zipObject, zipWith, λ,
    slice1 = [].slice,
    hasProp = {}.hasOwnProperty,
    indexOf1 = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _ = {};

  id = function(x) {
    return x;
  };

  K = function(x) {
    return function() {
      return x;
    };
  };

  builtin = id.bind.bind(id.call);

  toArray = builtin(Array.prototype.slice);

  variadic = function() {
    var as;
    as = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
    return as;
  };

  ncurry = function(n, f, as) {
    if (as == null) {
      as = [];
    }
    return function() {
      var bs;
      bs = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
      bs = as.concat(bs);
      if (bs.length < n) {
        return ncurry(n, f, bs);
      } else {
        return f.apply(null, bs);
      }
    };
  };

  λ = curry = function(f) {
    return function() {
      var as;
      as = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
      if (f.length > as.length) {
        return ncurry(f.length, f, as);
      } else {
        return f.apply(null, as);
      }
    };
  };

  apply = λ(function(f, as) {
    return f.apply(null, as);
  });

  applyNew = λ(function(f, as) {
    return new (f.bind.apply(f, [null].concat(slice1.call(as))));
  });

  partial = function() {
    var as, f;
    f = arguments[0], as = 2 <= arguments.length ? slice1.call(arguments, 1) : [];
    return function() {
      var args, bs, i;
      bs = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
      args = as.concat(bs);
      i = args.length;
      while (i--) {
        if (args[i] === _) {
          args[i] = args.splice(-1)[0];
        }
      }
      return f.apply(null, args);
    };
  };

  flip = λ(function(f, x, y) {
    return f(y, x);
  });

  flip3 = λ(function(f, x, y, z) {
    return f(z, y, x);
  });

  nflip = function(f) {
    return function() {
      var as;
      as = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
      return f.apply(null, as.reverse());
    };
  };

  unary = λ(function(f, x) {
    return f(x);
  });

  binary = λ(function(f, x, y) {
    return f(x, y);
  });

  nary = λ(function(n, f) {
    return function() {
      var as;
      as = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
      return f.apply(null, as.slice(0, n));
    };
  });

  compose = function() {
    var fs;
    fs = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
    return fs.reduce(function(f, g) {
      return function() {
        var as;
        as = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
        return f(g.apply(null, as));
      };
    });
  };

  pcompose = function() {
    var fs;
    fs = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
    return function(xs) {
      return xs.map(function(x, i) {
        return typeof fs[i] === "function" ? fs[i](x) : void 0;
      });
    };
  };

  sequence = nflip(compose);

  over = λ(function(f, g, x, y) {
    return f(g(x), g(y));
  });

  notF = function(f) {
    return function() {
      var as;
      as = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
      return !f.apply(null, as);
    };
  };

  eq = λ(function(x, y) {
    return y === x;
  });

  notEq = λ(function(x, y) {
    return y !== x;
  });

  typeOf = function(x) {
    return Object.prototype.toString.call(x).slice(8, -1);
  };

  isType = λ(function(t, x) {
    return typeOf(x) === t;
  });

  toObject = function(xs) {
    return xs.reduce(function(acc, x, i) {
      if (i % 2) {
        acc[xs[i - 1]] = x;
      }
      return acc;
    }, {});
  };

  extend = function() {
    var a, b, bs, k, l, len, v;
    a = arguments[0], bs = 2 <= arguments.length ? slice1.call(arguments, 1) : [];
    for (l = 0, len = bs.length; l < len; l++) {
      b = bs[l];
      for (k in b) {
        if (!hasProp.call(b, k)) continue;
        v = b[k];
        a[k] = v;
      }
    }
    return a;
  };

  deepExtend = function() {
    var a, b, bs, k, l, len, v;
    a = arguments[0], bs = 2 <= arguments.length ? slice1.call(arguments, 1) : [];
    for (l = 0, len = bs.length; l < len; l++) {
      b = bs[l];
      for (k in b) {
        if (!hasProp.call(b, k)) continue;
        v = b[k];
        a[k] = typeof v === 'object' ? deepExtend(a[k], v) : v;
      }
    }
    return a;
  };

  deepClone = function(obj) {
    var init;
    init = isType('Array', obj) ? [] : {};
    return Object.keys(obj).reduce(function(acc, k) {
      var mustClone, x;
      x = obj[k];
      mustClone = isType('Array', x) || isType('Object', x);
      acc[k] = mustClone ? deepClone(x) : x;
      return acc;
    }, init);
  };

  forOwn = λ(function(acc, f, obj) {
    Object.keys(obj).forEach(function(k, i) {
      return acc = f(acc, k, obj[k], i);
    });
    return acc;
  });

  fold = flip3(builtin(Array.prototype.reduce));

  fold1 = λ(function(f, xs) {
    return fold(xs[0], f, xs);
  });

  foldr = flip3(builtin(Array.prototype.reduceRight));

  foldr1 = λ(function(f, xs) {
    return foldr(xs[0], f, xs);
  });

  map = flip(builtin(Array.prototype.map));

  filter = flip(builtin(Array.prototype.filter));

  any = flip(builtin(Array.prototype.some));

  all = flip(builtin(Array.prototype.every));

  each = flip(builtin(Array.prototype.forEach));

  indexOf = flip(builtin(Array.prototype.indexOf));

  concat = builtin(Array.prototype.concat);

  slice = λ(function(i, j, xs) {
    if (j != null) {
      return xs.slice(i, j);
    } else {
      return xs.slice(i);
    }
  });

  first = function(arg) {
    var x, xs;
    x = arg[0], xs = 2 <= arg.length ? slice1.call(arg, 1) : [];
    return x;
  };

  last = function(arg) {
    var l, x, xs;
    xs = 2 <= arg.length ? slice1.call(arg, 0, l = arg.length - 1) : (l = 0, []), x = arg[l++];
    return x;
  };

  rest = slice(1, null);

  initial = slice(0, -1);

  take = slice(0);

  drop = partial(slice, _, null, _);

  inArray = λ(function(xs, x) {
    return indexOf1.call(xs, x) >= 0;
  });

  remove = λ(function(x, xs) {
    var ys;
    ys = xs.slice(0);
    ys.splice(xs.indexOf(x), 1);
    return ys;
  });

  uniqueBy = λ(function(f, xs) {
    var seen;
    seen = [];
    return xs.filter(function(x) {
      var fx;
      fx = f(x);
      if (fx == null) {
        return true;
      }
      if (indexOf1.call(seen, fx) >= 0) {
        return;
      }
      seen.push(fx);
      return true;
    });
  });

  unique = uniqueBy(id);

  dups = function(xs) {
    return xs.filter(function(x, i) {
      return xs.indexOf(x) !== i;
    });
  };

  flatten = function(xs) {
    var ref;
    while (xs.some(Array.isArray)) {
      xs = (ref = Array.prototype).concat.apply(ref, xs);
    }
    return xs;
  };

  union = compose(unique, flatten, variadic);

  intersection = compose(unique, dups, flatten, variadic);

  flatMap = flip(compose(flatten, map));

  pluck = λ(function(x, xs) {
    return String(x).split('.').reduce(function(acc, x) {
      if (acc == null) {
        return;
      }
      return acc[x];
    }, xs);
  });

  deepPluck = λ(function(x, xs) {
    var out;
    out = [];
    while (xs = pluck(x, xs)) {
      out.push(xs);
    }
    return out;
  });

  where = λ(function(obj, xs) {
    return xs.filter(function(x) {
      return Object.keys(obj).every(function(k) {
        return obj[k] === x[k];
      });
    });
  });

  deepWhere = λ(function(match, xs) {
    var find;
    find = λ(function(match, obj) {
      return Object.keys(obj).every(function(k) {
        var mustFind;
        mustFind = [obj[k], match[k]].every(function(x) {
          return isType('Object', x || isType('Array', x));
        });
        if (mustFind) {
          return find(match[k], obj[k]);
        }
        return match[k] === obj[k];
      });
    });
    return xs.filter(find(match));
  });

  values = function(obj) {
    var results, v;
    results = [];
    for (_ in obj) {
      if (!hasProp.call(obj, _)) continue;
      v = obj[_];
      results.push(v);
    }
    return results;
  };

  pairs = forOwn([], function(acc, k, v) {
    return acc.concat([[k, v]]);
  });

  interleave = λ(function(arg, ys) {
    var x, xs;
    x = arg[0], xs = 2 <= arg.length ? slice1.call(arg, 1) : [];
    if (x == null) {
      return ys;
    }
    return [x].concat(interleave(ys, xs));
  });

  intersperse = λ(function(x, xs) {
    var i, l, len, out, ref, y;
    out = [xs[0]];
    ref = xs.slice(1);
    for (i = l = 0, len = ref.length; l < len; i = ++l) {
      y = ref[i];
      out.push(x, y);
    }
    return out;
  });

  intercalate = compose(flatten, intersperse);

  zip = function() {
    var xss;
    xss = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
    return xss[0].map(function(_, i) {
      return xss.map(pluck(i));
    });
  };

  zipWith = function() {
    var f, xss;
    f = arguments[0], xss = 2 <= arguments.length ? slice1.call(arguments, 1) : [];
    return apply(zip, xss).map(partial(apply, f));
  };

  zipObject = compose(toObject, flatten, zip);

  unzipObject = forOwn([[], []], function(acc, k, v, i) {
    acc[0][i] = k;
    acc[1][i] = v;
    return acc;
  });

  range = λ(function(m, n) {
    var l, results;
    return (function() {
      results = [];
      for (var l = m; m <= n ? l <= n : l >= n; m <= n ? l++ : l--){ results.push(l); }
      return results;
    }).apply(this);
  });

  shuffle = function(xs) {
    var i, j, l, len, ref, ys;
    ys = xs.slice(0);
    for (i = l = 0, len = ys.length; l < len; i = ++l) {
      _ = ys[i];
      j = Math.random() * (i + 1) | 0;
      ref = [ys[j], ys[i]], ys[i] = ref[0], ys[j] = ref[1];
    }
    return ys;
  };

  sortBy = λ(function(f, xs) {
    return xs.sort(function(x, y) {
      var fx, fy;
      fx = f(x);
      fy = f(y);
      switch (false) {
        case !(fx > fy):
          return 1;
        case !(fx < fy):
          return -1;
        default:
          return 0;
      }
    });
  });

  groupBy = λ(function(f, xs) {
    return xs.reduce(function(acc, x) {
      var fx;
      fx = f(x);
      acc[fx] = (acc[fx] || []).concat([x]);
      return acc;
    }, {});
  });

  countBy = sequence(groupBy, forOwn({}, function(acc, k, v) {
    acc[k] = v.length;
    return acc;
  }));

  format = λ(function(xs, x) {
    return x.replace(/%(\d+)/g, function(_, i) {
      return xs[--i] || '';
    });
  });

  template = λ(function(obj, x) {
    return x.replace(/#\{(.+?)\}/g, function(_, k) {
      return obj[k] || '';
    });
  });

  gmatch = λ(function(re, x) {
    var out;
    out = [];
    x.replace(re, function() {
      var as;
      as = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
      return out.push.apply(out, as.slice(1, -2));
    });
    return out;
  });

  permutations = function(xs) {
    var l, len, len1, o, out, ref, x, ys;
    if (!xs.length) {
      return [[]];
    }
    out = [];
    for (l = 0, len = xs.length; l < len; l++) {
      x = xs[l];
      ref = permutations(remove(x, xs));
      for (o = 0, len1 = ref.length; o < len1; o++) {
        ys = ref[o];
        out.push([x].concat(ys));
      }
    }
    return out;
  };

  powerset = function(arg) {
    var x, xs, xss;
    x = arg[0], xs = 2 <= arg.length ? slice1.call(arg, 1) : [];
    if (x == null) {
      return [[]];
    }
    xss = powerset(xs);
    return interleave(xss, xss.map(binary(concat, [x])));
  };

  fmap = λ(function(f, ma) {
    return ma.map(f);
  });

  ap = λ(function(mf, ma) {
    return ma.ap(mf);
  });

  chain = λ(function(f, ma) {
    return ma.chain(f);
  });

  liftA = λ(function(ctor, f, ms) {
    return ms.reduce(function(acc, ma) {
      return acc.ap(ma);
    }, ctor.of(f));
  });

  seqM = λ(function(ctor, ms) {
    return ms.reduceRight(function(ma, mb) {
      return ma.chain(function(a) {
        return mb.map(function(b) {
          return [b].concat(a);
        });
      });
    }, ctor.of([]));
  });

  module.exports = {
    _: _,
    id: id,
    K: K,
    builtin: builtin,
    toArray: toArray,
    variadic: variadic,
    apply: apply,
    applyNew: applyNew,
    ncurry: ncurry,
    λ: λ,
    curry: curry,
    partial: partial,
    flip: flip,
    flip3: flip3,
    nflip: nflip,
    unary: unary,
    binary: binary,
    nary: nary,
    compose: compose,
    pcompose: pcompose,
    sequence: sequence,
    over: over,
    notF: notF,
    not: notF,
    eq: eq,
    notEq: notEq,
    typeOf: typeOf,
    isType: isType,
    toObject: toObject,
    extend: extend,
    deepExtend: deepExtend,
    deepClone: deepClone,
    forOwn: forOwn,
    fold: fold,
    fold1: fold1,
    foldr: foldr,
    foldr1: foldr1,
    map: map,
    filter: filter,
    any: any,
    all: all,
    each: each,
    indexOf: indexOf,
    concat: concat,
    slice: slice,
    first: first,
    last: last,
    rest: rest,
    initial: initial,
    take: take,
    drop: drop,
    inArray: inArray,
    remove: remove,
    uniqueBy: uniqueBy,
    unique: unique,
    dups: dups,
    flatten: flatten,
    union: union,
    intersection: intersection,
    flatMap: flatMap,
    pluck: pluck,
    deepPluck: deepPluck,
    where: where,
    deepWhere: deepWhere,
    values: values,
    pairs: pairs,
    interleave: interleave,
    intersperse: intersperse,
    intercalate: intercalate,
    zip: zip,
    zipWith: zipWith,
    zipObject: zipObject,
    unzipObject: unzipObject,
    range: range,
    shuffle: shuffle,
    sortBy: sortBy,
    groupBy: groupBy,
    countBy: countBy,
    format: format,
    template: template,
    gmatch: gmatch,
    permutations: permutations,
    powerset: powerset,
    fmap: fmap,
    ap: ap,
    chain: chain,
    liftA: liftA,
    seqM: seqM
  };

  module.exports.expose = partial(extend, _, module.exports);

}).call(this);
